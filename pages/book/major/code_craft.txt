====== Code Craft:뛰어난 코드 작성을 위한 실전 지침 ======

  * 피트 구들리프 지음, 김윤명 옮김
  * 한빛미디어

----
===== 0. 서문 =====

  * **코드 장인이 되기 위해서는 기술 이상의 것이 필요**
  * 코드 장인과 코드 장이의 차이
    * 장이는 그저 그런 코드를 작성하고 장인은 뛰어난 코드를 작성한다.
  * 장이와 장인의 결과 차이는 일을 대하는 태도의 차이
    * 장이: 억지로, 대충
    * 장인: 소명의식이 있음, 더 좋은 프로그램을 향한 노력
  * 열심히 하나 요령껏 하나 월급은 똑같아도 결과적으로는 코드 장인처럼 하는 것이 이득
    * //길게 봤을때는 그러하나.. 회사를 곧 나갈 상황이라면?//
  * 장이가 만든 프로그램은 예기치 못한 상황에서 고장이 나기 쉽고 문제를 고치는데 있어서도 어려움이 따름
    * 심지어는 문제를 고치는 과정에서 다른 문제가 발생할 수도 있음
  * 장인이 만든 프로그램은 예상치 못한 상황에서도 대처가 가능하고 새로운 요구를 위한 솔루션을 빠르게 마련할 수 있음
  * 명작 프로그램의 특징
    * <del>현란한 기교, 독특한 개성, 기발하고 신기함</del> 이런 것이 아님
    * 가독성이 좋음
    * 복잡한 문제를 단순한 방법으로 처리함
  * 이 책에서는 명작 프로그램을 작성하기위한 기술들을 소개함
    * 프로그램으로 하려는 일에 대해 더욱 깊게 생각하고 더 넓은 관점에서 바라볼 수 있는 방법들이 소개됨
    * 하지만 보기만 해서는 효용이 적고 각 기법들을 직접 써보면서 몸에 익혀야 가치가 있음
  * 이 책에 명작 코드를 작성하기 위한 기술들이 모두 소개된 것은 아니지만 적어도 더 좋은 코드를 만들 수 있는 기반은 마련해 줄것

===== 1. 코드와 마주보기 =====

  * <code>
프로그래머는 프로그램을 작성합니다. 이 사실을 알기 위해서는 천재적 두뇌가 필요치 않습니다.
하지만 더 미묘한 구분이 있습니다. 좋은 프로그래머만이 습관적으로 좋은 코드를 작성합니다.
나쁜 프로그래머는... 그렇지 않습니다. 나쁜 프로그래머는 작성하기보다 고치는 데 더 많은
노력이 드는 허접 쓰레기를 만들어 냅니다.
</code>
  * //코드 개발의 세세하고 실무적인 양상, 방어적인 프로그래밍, 코드 포맷 및 레이아웃 구성법, 지속적인 코드 네이밍, 문서화, 코멘트 작성 관례, 에러 핸들링 기술//
  * 프로그래머는 외부의 방해 없이 오롯이 코드 작성에만 집중하고자 하지만 현업에서는 주변 상황의 변화((요구사항, 예산, 데드라인 등등의 변화))가 프로그래머를 가만두지 않는다. 이 장에서는 변화 무쌍한 현실에서도 자신을 방어하며 좋은 코드를 작성하는 기술을 소개한다.
 

==== 방어하기 ====

  * <code>
우리는 서로를 믿지 말아야 합니다. 그것이 배신에 대한 유일한 방어책입니다.
- 테네시 윌리암즈
</code>
  * //튼튼한 코드를 작성하기 위한 방어적 프로그래밍 기술//
  * 훌륭한 코드를 향해서
    * 작동할 것처럼 보이는 코드 vs 올바른 코드 vs 훌륭한 코드
      * 작동하는 코드: 작성하기 쉬움, 의외의 값에 취약
      * 올바른 코드: 모든 입력에 대해 올바른 출력
      * 훌륭한 코드: 올바른 코드 + 가독성이 높음, 유지보수가 쉬움
    * 훌륭한 코드를 목표로 하는 과정에서 많은 요구사항이 충족될 수 있음
    * 주변 상황은 계속 변하고 기술은 빠르게 발전하며 괴상한 기존 코드가 있는 곳이 바로 실전! 실전은 훌륭한 코드의 작성을 방해한다.
    * 방해 가득한 실전에서 훌륭한 코드를 작성하는 법. 그것이 바로 방어적 프로그래밍((defensive programming))
    * 방어적 프로그래밍은 보편적으로 적용하여 코드에 잠재적인 문제가 숨어드는 것을 방지할 수 있는 기초적인 지침들
  * 최악을 가정하라
    * 코드를 작성할 당시엔 프로그래머의 추측이 들어가게 되나 이러한 추측은 시간이 지나면 희미해짐.(("내가 이 코드를 왜 이렇게 짰더라?!" 하는 상황이 발생하게 될거다))
    * 코드 수정 기간이 촉박하여 전체 구조를 파악할 시간이 없어 코드 작동 방식을 추측하여 코드를 짜면 정상 동작하는지 알기 힘들다.
    * 추측은 소프트웨어 결함의 원인이 됨
    * 방어적 프로그래밍을 위해서는 아무 것도 추측은 금물!
    * "나의 코드는 언제 어떻게든 잘못 사용될 가능성이 있다"는 것만이 유일하게 확신할 수 있는 부분
    * 나의 추측은 다른 프로그래머에게 혼란을 주거나 코드가 변경 되었을때 나조차도 알지 못할 수 있으므로 약간의 강박증이 필요
    * 잘못된 소프트웨어는 시스템의 장애((디스크 부족, 네트워크 오류, 시스템 다운 등))를 발생할 수 있다는 사실을 명심
    * 외부의 상황이 빠르게 돌아갈수록 소프트웨어 에러를 최소화 할 기회를 포착하고 추측을 검증하는 습관(방어적인 습관)이 무기가 될 수 있음
  * 방어적 프로그래밍이란?
    * 가능한 오동작에 대한 보호 기법을 최대한 도입하고 예기치 못한 오동작을 관찰하려는 시도
    * 방어적 프로그래밍은 사소한 문제가 심각한 재난으로 변화하는 것을 방지할 수 있음
    * 방어적 프로그래밍은 "디버그 -> 실행 -> 에러 -> 디버그 -> 실행 -> 에러 -> ... "의 사이클을 벗어나 "코딩 -> 테스트 -> 실행"의 단계로 프로그래밍이 진행되도록 유도
    * 방어적 프로그래밍이 모든 결함을 잡아낼 수 있는 것은 아니지만 결함을 찾아내고 그것을 고치는 과정을 쉽게 만들어 줄 수 있음
    * 방어적 프로그래밍은 치료 행위라기 보단 예방법!
    * 방어적 코딩은 효율성을 저해하고 일을 추가로 만드는 것처럼 보이지만 실제로는 다음과 같은 장점들이 있음
      * 디버깅 시간을 줄여서 남는 시간에 더 흥미롭고 의미있는 일을 더 할 수 있음
      * 이따금 붕괴하는 코드보다는 조금 느리지만 올바르게 작동하는 코드를 작성할 수 있도록 함
      * 상당수의 보안 관련 문제를 예방할 수 있음
    * 길게 보았을때 방어적 프로그래밍에 의한 추가 작업은 추후의 결함 폭탄과 개발 지연으로부터 우리를 구해줌
  * 험한 세상
    * 세상에는 자의든 타의든 악의적인 사용자들이 존재
    * 방어적 프로그래밍은 엉성한 코드를 작성할 가능성을 배제함으로써 악의적인 사용자들이 소프트웨어를 위협할 여지를 줄여줌
    * 네트워크로 연결된 환경이 확장되면서 악의적인 사용자들이 소프트웨어를 위협할 가능성도 확대
    * 최근 이러한 위협을 깨닫고 방어적 코딩 작업에 시간과 자원을 투자하는 대규모 회사들도 증가하는 추세
  * **방어적 프로그래밍을 위한 테크닉**
    * 방어적 프로그래밍에 대해 생각할 때 통상적으로 Assersions((프로그램이 오동작 할 수 있는 부분에서 오류 메시지를 발생하고 프로그램을 중단하는 기술))이 먼저 떠오르지만 이외에도 코드 안정성을 위한 단순한 프로그래밍 습관도 존재
    * 코드 안정성을 위한 습관들은 상식처럼 보이지만 무시되는 경향이 있는데 이러한 습관들을 경각심을 가지고 실천하면 보안 수준이 높고 동작에 신뢰도가 높은 프로그램을 쉽게 작성할 수 있음
    * 이후의 내용들은 방어적 프로그래밍의 규칙들을 코드 예시와 함께 소개할 것((이후 나열되는 규칙들 중 몇개나 실천하고 있으며 어떤 것을 취할지 생각해보자))
    * 좋은 코딩 스타일과 건강한 설계를 채용하라
      * 의미있는 변수 이름을 고르거나 괄호를 분별 있게 사용하는 등의 좋은 코딩 습관은 실수를 줄여줌
    * 코드 작성을 서두르지 마라
      * 흔히 일어나는 치고 빠지는 프로그래밍((함수를 급하게 만들어서 문법 체크만 거친 뒤 동작 확인을 했을때 동작이 되면 그냥 넘어가는 식의 프로그램))은 위험으로 가득찬 접근법
      * 치고 빠지는 프로그래밍을 하기 보다는 어떤 에러가 발생할지, 논리적인 모순은 없는지 프로그램 코드 각 행마다 신중하게 생각하여 프로그램을 작성하면 실수는 줄어들 수 밖에 없음
      * 천천히 코드를 작성하면서 gotcha((코드 문법 상으로는 틀리지 않지만 직관적으로 보이는 것과는 다른 동작을 하는 코드 Ex) = vs == ))에 유의
      * 프로그램의 단락을 작성하는 싸이클을 정하면 그것에 꼭 따라야 함
        * 한 싸이클의 해야하는 작업을 하지 않고 다음 단계로 넘어가면 남은 작업을 추후에 꼭 할거라는 보장도 없고 막상 나중에 가면 귀찮고 어려운 작업이 되어 돌아옴
        * __지금 하지 않으면 미래에도 하지 않을 가능성이 크며 그 가능성은 시간이 지나면서 점점더 커질것__
        * __나중에 하면 지금 하는 것보다 더 많은 노력이 필요__
    * 아무도 믿지 마라
      * 좋은 의도를 가진 사용자조차 프로그램에 문제를 일으킬 수 있으므로 좋은 프로그램을 위해서는 냉소적이고 방어적으로 행동할 필요가 있음
      * 프로그램에 문제를 일으킬 수 있는 사용자는 다음과 같음((이렇게나 많다))
        * 우연히 엉터리 데이터를 입력하거나 프로그램을 잘못 구동하는 **정직한 사용자**
        * 의식적으로 프로그램에 오동작을 발생하는 **악의적 사용자**
        * 잘못된 방식으로 프로그램을 호출하거나 모순된 데이터를 입력하는 **클라이언트 코드**
        * 프로그램에 적절한 서비스를 제공하지 못하는 **운영 환경**
        * 오동작 하거나 프로그램이 사용하는 인터페이스 규격을 따르지 않는 **외부 라이브러리**
      * 코드를 만든 사람조차도 코드 구동 방법을 잊어버리고 잘못 사용할 수 있기 때문에 모든 코드가 올바르게 작동할 것이라는 가정은 금물, 적절한 곳에서 안정성 체크
    * 짧은 코드가 아니라 명료한 코드를 작성하라
      * 세련미 있는 짧은 코드보다는 내가 의도한 대로 읽히는 명료한 코드가 항상 더 좋음
      * 내 코드를 읽는 사람이 내 의도를 정확히 파악하지 못하면 코드를 읽고 수정하는 사람이 실수할 확률이 높아짐 -> 유지 보수성이 엉망이 됨
      * 유지 보수될 수 없는 코드는 안전하지 못하다는 것을 명심할 것
      * "단순한 것이 좋은 것입니다. 코드를 절대 필요 이상으로 복잡하게 만들지 마십시오"
    * 어설프게 만지면 안 되는 것은 아무도 못 만지게 하라
      * 지저분하게 작성한 내부의 사적인(private) 코드를 다른 사람들이 접근할 수 없도록 기술적으로 막아야 프로그램에 실수가 들어가는 것을 방지할 수 있음
      * __협업 할때는 어떻게 하지?__
      * 사적인 코드를 은닉하는 기술들
        * 객체지향 언어는 private 키워드를 활용, 특히 C++ 에서는 pimpl 관용구(("private implementation idiom"의 준말, 포인터를 이용해서 데이터 타입의 내부 구현을 감추는 테크닉))의 사용을 고려해볼 것
        * 절차적 언어에서도 객체지향 패키징 개념을 사용할 수 있음. opaque type((내부 메커니즘과 구조를 외부에서 접근하거나 사용할 수 없는 데이터 타입))을 알아볼 것
        * 변수를 그 변수가 속할 수 있는 가장 좁은 범위 안에 둘 것!
    * 경고 스위치를 전부 켜놓고 컴파일하라
      * 컴파일러가 자체적으로 코드의 결함을 체크하여 경고를 출력하는 기능은 선택적으로 끌 수가 있음
      * 보통은 컴파일러의 경고를 꺼두거나 무시하는 방향으로 반응하는데 정말 나쁜 습관
      * 컴파일러 경고는 항상 사용 가능 상태로 설정해 두고 경고가 발생하면 즉시 컴파일러의 경고를 해결해야 함
      * 컴파일러의 경고가 너무 많으면 정작 중요한 경고를 눈치채지 못하고 넘어갈 수 있음
    * 정적 분석 툴을 사용하라
      * 각 언어 별로 존재하는 정적 분석 툴((예를들어 C 언어에는 lint가 있고, perl에는 perl::critic이 있다))을 쓰면 훨씬 더 많은 에러를 잡아낼 수 있음
      * __적극적으로 쓰자!__
    * 안전한 데이터 구조를 사용하라
      * 안전한 데이터 구조를 사용할 수 없으면 위험한 데이터 구조를 안전하게 사용할 것
      * 데이터를 안전하지 않게 사용하는 가장 흔한 경우는 buffer overrun((고정된 크기의 데이터 구조에 데이터 구조 크기보다 더 많은 데이터를 써 넣으려는 시도)) <code c>
char *unsafe_copy(const char *source)
{
    char *buffer = new char[10];
    strcpy(buffer, source);
    return buffer;
}
</code>
        * 위와 같은 코드에서 source 변수의 데이터 길이가 10문자를 초과하면 데이터 손상이 있을 수 있음
        * 그러나 데이터 손상은 최선의 경우이고 잘못되면 메모리 상의 바로 뒤에 위치한 공간을 점유하고 있는 변수가 있으면 그 변수가 예기치 못하게 변경될 수 있음
        * 이러한 특성을 악의적으로 이용하면 보안에 심각한 문제가 생길 수 있음
      * 관리 기능이 있는 버퍼를 사용하거나 데이터에 대한 안전 장치를 두면 아주 간단하게 취약점을 보완할 수 있음 <code c>
char *unsafe_copy(const char *source)
{
    char *buffer = new char[10];
    strncpy(buffer, source, 10);
    return buffer;
}
</code>

===== 2. 코드의 비밀스러운 일생 =====

  * //코드 작성의 프로세스, 빌드 툴, 테스트 방법, 디버깅 기술, 올바른 실행 파일을 빌드하는 절차, 최적화//

===== 3. 코드의 모습 =====

  * //코드의 설계, 소프트웨어 아키택처, 시간에 따른 코드의 변화//

===== 4. 프로그래머의 무리? =====

  * //바람직한 개발 관례, 개인과 팀의 바람직한 프로그래밍, 리비전 컨트롤 시스템//

===== 5. 프로세스의 일부 =====

  * //개발 프로세스(규격서 작성, 코드 리뷰, 소요 시간 측정)//

===== 6. 정상으로부터의 조망 =====

  * //개발 방법론, 높은 수준의 개발 프로세스 및 프로그래밍 분야//






