====== 클린 코드 ======

===== 문서 개요 =====

  * 클린 코드(clean code)에 대한 개념을 정리한 문서
  * 클린 코드를 유지하기 위해 지켜야 할 원칙들을 정리한 문서

----

===== 주요 내용 =====

 클린 코드는 말 그대로 깨끗한 코드를 의미한다. "깨끗하다"는 단어의 해석에 따라 여러가지 정의가 가능하나 대체로 "읽기 쉬운 코드"라고 생각하면 편하다.

===== 깨끗한 코드! =====

 클린 코드는 말 그대로 깨끗한 코드를 의미한다. "깨끗하다"는 단어의 해석에 따라 여러가지 정의가 가능하며 실제로 많은 유명 프로그래머들이 각자의 정의를 내놓았다.각각의 정의들을 자세히 살펴보면 다음과 같다.

  * 비야네 스트롭스트룹(CPP 창시자) <code>
나는 우아하고 효율적인 코드를 좋아한다. 논리가 간단해야 버그가 숨어들지
못한다.의존성을 최대한 줄여야 유지보수가 쉬워진다. 오류는 명백한 전략에
의거해 철저히 처리한다. 성능을 최적으로 유지해야 사람들이 원칙 없는
최적화로 코드를 망치려는 유혹에 빠지지 않는다. 깨끗한 코드는 한 가지를
제대로 한다.
</code>

  * 그레디 부치(객체지향의 대가) <code>
깨끗한 코드는 단순하고 직접적이다. 깨끗한 코드는 잘 쓴 문장처럼 읽힌다.
깨끗한 코드는 결코 설계자의 의도를 숨기지 않는다. 오히려 명쾌한 추상화와
단순한 제어문으로 가득하다.
</code>

  * 데이브 토마스(실용주의 프로그래머) <code>
깨끗한 코드는 작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.
</code>

  * 마이클 페더즈 <code>
깨끗한 코드의 특징은 많지만 그 중에서도 모두를 아우르는 특징이 하나있다.
깨끗한 코드는 언제나 누군가 주의깊게 짰다는 느낌을 준다. 고치려고
살펴봐도 딱히 손 댈 곳이 없다. 작성자가 이미 모든 사항을 고려했으므로.
고칠 궁리를 하다보면 언제나 제자리로 돌아온다. 그리고는 누군가 남겨준
코드, 누군가 주의깊게 짜놓은 작품에 감사를 느낀다.
</code>

  * 워드 커닝엄(위키 & 익스트림 프로그래밍 창시자) <code>
코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면
깨끗한 코드라 불러도 된다.
코드가 그 문제를 풀기위한 언어처럼 보인다면
아름다운 코드라 불러도 된다.
</code>

 여러 사람들이 각각 다르게 정의하지만 대체로 "읽기 쉬운 코드"((의도가 자명하고 중복이 없음))에 대한 중요성과 이점에 관한 이야기이다.

===== 클린 코드의 중요성 =====

 읽기 어려운 코드는 전체적인 구조나 동작 방법의 파악을 방해하고 코드 수정 과정에서의 실수를 유발하여 개발 효율성을 크게 저해한다. 반면, 명료하고 간단한 형태로 작성된 코드는 개발자가 읽기 편하므로 이러한 개발 효율성 저해 요소를 최소화한다. 따라서 개발자의 작업 효율을 최대로 끌어올리기 위해서는((코드의 수정과 새코드의 추가가 용이하게 하려면)) 읽기 좋은 코드를 최우선 목표로 하여 코드를 작성하는 클린 코드의 양식을 따르는 것이 중요하다. 클린코드 해라. <del>두번해라.</del>

----
===== 클린 코드 작성을 위한 원칙 =====

==== 공통 ====

  * 코드를 쓰는 것보다 읽는 것이 더 중요하다 생각해라.((코드 읽기와 쓰기의 비율을 10:1로 생각할 것))
  * 보이스카우트 규칙((캠프장은 처음 왔을 때보다 더 깨끗하게 해놓고 떠나라!))을 잊지말자. 전문가 정신이란 지속적으로 개선하려는 노력이다!
  * 당연한 얘기지만 팀에 속해있고 팀 자체 규칙이 있다면 그것이 우선이다!
    * 코딩을 시작하기 전에 코딩 스타일을 의논하고 의논한 내용을 IDE Formatter에 적용하여 구현하는 것이 좋음.

==== 변수 ====

  * 변수명은 명료하게!
    * 이름에 분명한 의도를 드러내자.
    * 이름에 의미를 왜곡할 수 있는 정보는 넣지말자.
    * 의미 없는 이름을 사용하지말자.
    * 개발자들 사이의 의사소통을 위해 이름은 발음하기 쉽게 만들자.
    * 이름은 생소하지 않은 단어들로 구성하자.
    * 상수는 대문자로 하는 등 이름에 특성을 넣어 검색이 쉽게 하자.
    * 변수 이름에 암호화((변수 이름을 풀이하는 규칙을 넣는것)), 헝가리안 표기((타입을 접두어로 나타낸것, 변수의 형태는 리팩토링에 의해 얼마든지 바뀔 수 있으므로 지양할 것))를 쓰지말자.
    * 이름은 일관성 있게 부여하자.
      * 하나의 개념에는 하나의 용어를 사용
      * 요구사항, 설계에서 정의한 용어를 그대로 사용
      * 맥락에 맞는 접두어를 사용하되 너무 남발하지 말것!
    * 명료하지 않은 이름의 극단적인 예) 이모티콘을 변수명을 사용하는 경우(최악..) <code go>
class ㅡ.ㅡ
{
    func -_-(o-o: Int, ^^: Int) -> Int
    {
        return o-o + ^^
    }
}

var <(o3) = 3
var ㅡㅡ; = <(o3) +2

var ㅇㅅㅇ = ㅡ.ㅡ()
println(ㅇㅅㅇ.-_-(<(o3), ^^:ㅡㅡ;)
</code>

  * 결과를 즉시 처리하거나 중간 결과값을 저장하는 변수를 제거하여 변수 사용을 최소화 해야한다.
  * 변수가 사용되는 범위를 최소화해야 함
  * 값이 한번만 할당되는 const, final 등의 정적 변수가 이해하기 쉽다.

==== 함수 ====

  * 기능을 가능한 한 잘게 쪼개서 작은 함수 많이 만드는 것이 좋다!
  * 함수는 최대 20줄((5줄을 넘기지 말라는 사람도 있다..))을 넘기지 말자. 들여쓰기도 2단까지만!!
  * 함수는 한 가지 작업만!(단일 책임 원칙)
  * 위에서 아래로 자연스럽게 읽히도록 작성하자.
    * 한 함수 다음에는 추상화 수준이 한단계 낮은 함수!
  * switch 문을 반복하지 말고, 다형성을 활용
    * switch 문은 작게 만들기도 어려울 뿐더러 여러가지 일을 하는 함수를 만든다.
  * 함수 이름에 공을 들이자.
    * 되도록 동사형으로!
    * 때로는 문학적인 표현도 유용
    * 접근자, 변경자, 조건자는 get, set, is로 시작할 것!
  * 인수는 3개를 넘기지 않는 것이 좋다.
    * 인수가 아예 없는 것이 가장 좋은 함수
    * 어쩔수 없이 인수가 많다면 캡슐화를 하는 방법이 효과적
  * 출력 인수 대신 반환을 쓰자.
  * 인수로 넘어온 것의 값을 변경하는 것을 지양하여 부작용을 줄이자!
  * 플래그 인수를 사용하는 대신 함수 내에 조건문을 넣는게 낫다.
    * 플래그 인수를 사용하면 함수가 한가지만 하는 규칙에 어긋남
  * 명령을 수행하는 command 형 함수와 정보를 사용자에게 전달하는 query 형 함수를 구분해서 작성하자.

==== 코드 흐름 제어 ====

  * 코드 흐름을 읽기 쉽게 만들면 논리가 명확해진다.
  * if/else 블록의 순서는 긍정적이고 쉽고 흥미로운 경우를 앞쪽에 배치하는게 좋다.
  * 삼항연산자(A?B:C), do/while, goto는 코드 가독성을 저해한다.
  * 선형적인 흐름을 가진 코드가 읽기에 좋다.((재귀적인 코드는 지양할 것))
  * 함수 중간의 return을 사용하여 재귀적인 구조를 피하자.

==== 주석 ====

  * 잡음을 줄이고 의도를 명확하게 할 것!
  * 기록하지 말아야 할 내용
    * 코드 자체에서 직관적으로 도출될 수 있는 사실
    * 나쁘게 작성된 코드를 보정하려 "애쓰는 주석"((이럴때는 주석을 쓸 시간에 코드를 수정하자.)) <del>화장품 주석</del>
    * 주절대는 주석
    * 정확하지 않은 정보
  * 기록해야 하는 내용
    * 코드 작성 방식의 이유((왜 코드를 이렇게 짰는가))를 설명하는 내용
    * 코드에 담긴 결함(("TODO", "FIXME", "XXX", "HACK", "BUG", "NOTE"와 같이 IDE가 인식할 수 있는 것을 사용하는 것을 권장))
    * 어떤 상수가 특정 값으로 정해진 이유
    * 평범한 사람이 예상치 못한 특이한 동작 방식
  * 큰 그림을 설명하고 해당 구성 요소가 어떤 역할을 하는지를 설명하는 파일이나 클래스 수준의 주석은 강추!
  * 대부분의 경우 주석이 필요한 상황이면 코드 자체에 충분한 의도를 나타낼 수 없는 것! 주석 대신 코드를 어떻게 명확하게 할까를 고민하자.

==== 코드 형식 ====

  * 파일 길이, 행 길이(100자 이내)는 짧을수록 좋다.((가장 읽기 좋은 코드는 아무것도 없는 코드?!))((코드 분량이 적으면 테스트/유지보수/문서화에 유리함))
    * 제품에 필요하지 않는 기능은 주석처리 하지말고 제거한다.
    * 요구사항을 재고하여 가장 단순한 형태로 해결하는 것이 적은 코드 분량을 유지하는데 도움이 된다.
    * 프레임워크/라이브러리 API로 제공하는 기능을 최대한 활용하는 것이 좋다. ((주기적으로 관련 정보를 찾아보는 것이 선행되야 함)) 
  * 심미적인 요소도 신경써야 한다.((보기 좋은 코드가 읽기도 좋다.))
    * 여러 블록에 담긴 코드가 비슷한 일을 하면 실루엣을 동일하게 구성할 것!
    * 코드 곳곳을 '열'로 만들어 줄을 맞출것!
    * 빈 줄을 이용해 커다란 블록을 논리적인 '문단'으로 나눌 것
  * 서로 밀접한 개념은 가까이에 놓자.
  * 신문기사처럼 최상단에는 큰 개념을, 내려갈수록 작은 개념을 놓는다.

==== 절차 지향 작성법 vs. 객체 지향 작성법 ====

  * 목적에 맞게 적절한 방식으로 코드를 작성해야 한다.
  * 자료구조와 객체를 섞어서 쓰면 양쪽의 장점을 모두 갖는것 같지만 단점도 모두 가지게 되므로 하지말자.
  * 도움의 될만한 것들
    * DTO(DataTransferObject)
      * 오직 자료를 전달하는 역할만 하는 객체((자료구조와 비슷한 형태))
      * get/set류 이외의 메소드가 없다.
    * ActiveRecord [[http://codeigniter-kr.org/user_guide_2.1.0/database/active_record.html|예시]]
      * 여러 종류의 DB 인터페이스를 동일한 인터페이스로 사용할 수 있도록하는 코드 설계 패턴
      * 일종의 인터페이스 wrapper!

++++cf) 두 작성법의 차이점|
|                 ^^  절차 지향 작성법   ^  객체 지향 작성법       |
^논리 단위  |  명칭  |  자료 구조          |  객체(클래스)          |
^:::      |  동작  |  없음              |  공개                 |
^:::      |  자료  |  공개              |  숨김                 |
^  이점           ||새 동작을 추가하기 용이|새 개체 타입을 추가하기 용이|
^  단점           ||새 자료 구조를 추가하려면 모든 함수를 고쳐야 함|새로운 함수를 추가하려면 모든 클래스를 고쳐야 함|
++++
==== 오류 처리 ====

  * null은 정말로 없는 것인지 없다고 표현한 것인지 뜻이 모호하므로 반환하지도 말고 전달하지도 말자.
  * 오류 코드의 활용은 다음과 같은 단점이 있으므로 지양하자.
    * 조건문의 반복으로 가독성을 저해하고 중심 논리를 흐리는 경향이 있음
    * 호출하는 쪽에서 오류코드를 처리해주어야 하는데 이를 깜빡하는 경우도 생길 수 있음
    * 오류코드 하나가 바뀌면 그 함수를 호출하는 모든 코드를 확인하여 변경해야 하여 번거로움
  * 오류 코드보다는 다음과 예외 처리 기법을 사용하자.
    * try-catch-finally
    * autocloseable((java에서 쓰는 예외 처리 라이브러리))
    * unchecked_exception
      * 예외를 강제하지는 않을것! 필요한 곳에 필요한 만큼의 exception을 배치해야 한다.
      * cf) checked_exception: 함수를 호출할 때 예외 처리를 명시적으로 하지 않으면 컴파일도 하지 못하게 하는 예외 강제 기법

==== 테스트 ====

  * TDD(Test Driven Development) 법칙을 지키자
    * 유의 사항
      * 실패하는 코드 먼저 작성
      * 컴파일만 되는 정도의 테스트 코드 작성
      * 실패하는 코드가 통과하는 정도만 확인할 것
  * 테스트에 실패했을 때 버그 추적에 도움이 되는 오류 메시지를 출력하는 테스트 코드가 좋다.
  * 테스트 코드는 코드의 구석구석을 철저히 실행해야 한다.
  * 테스트 함수의 이름에는 테스트 대상이 무엇인지 분명히 하기위한 설명을 포함해야 한다.
  * 테스트의 수정이나 추가가 편해야 한다.
  * 단위 테스트 기법을 활용하는 것이 좋다.
    * F((Fast, 빠르게 테스트 할 수 있음, 테스트 코드가 빠르게 돌지 않으면 테스트를 자주 돌릴수 없어 디버깅 효율을 저해함)).I((Independent, 각 단위 테스트는 서로 의존하지 않음, 테스트가 서로에게 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워짐)).R((Repeatable 어떤 환경에서도 반복이 가능함, 어떤 환경에서도 반복할 수 있는 테스트 코드는 여러 플랫폼에서의 버그를 잡아낼 수 있음)).S((Self-validating, 테스트의 결과는 부울값으로~, 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 됨)).T((Timely(적시에), 테스트 코드는 실제 코드를 구현하기 직전에 구현할 것! 테스트 코드를 나중에 만들면 테스트가 불가능하도록 실제 코드를 설계할 가능성이 생김)) 원칙을 기반으로 하는 테스트
    * 단위 테스트는 일회용이 아니라 자동화를 염두에 두고 작성할것!
    * 단위 테스트 코드도 가독성이 높아야 한다.
  * build-operate-check 패턴을 사용하는 것이 좋다.
    * build: 테스트 자료를 생성
    * operatie: 테스트 자료를 조작
    * check: 조작한 결과가 올바른지 확인
    * 위 세 단계로 명확히 나뉜 테스트가 build-operate-check 패턴을 따르는 테스트
    * 잡다하고 세세한 코드 없이 곧바로 본론으로 들어가는 구조이므로 build-operate-check 패턴을 따르는 테스트 코드는 이해하기 쉽다.
  * given-when-then 패턴도 강추!
    * build-operate-check와 비슷한 구조를 따르는 코딩 패턴이지만 사용자의 행동 패턴에 초점을 더 맞춘 방식이다.
    * given: 특정 상황을 조성
    * when: 어떤 이벤트를 발생함
    * then: 해당 이벤트에 따른 결과
    * given-when-then의 세단계로 나누어 테스트 코드를 구성하면 테스트 코드가 무엇을 하는지, 그에 따른 결과가 맞는지 확인하는 루틴을 쉽게 작성할 수 있고 가독성도 좋아진다. 
  * 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위 테스트이다.
    * 단위 테스트를 한번 돌려보는 것만으로 변경된 코드로 인해 버그가 발생했는지 알 수 있으므로 단위 테스트는 코드를 변경하는 것을 거리낌 없이 하도록 해준다.
  * 클린 코드와는 상반되는 규칙을 적용해야 하는 부분도 있다.
    * 테스트에서는 약어를 쓰는 것이 경제적이다.
    * string buffer를 많이 써서 가독성을 높이는 것이 좋다.
  * 테스트 함수마다 한 개념만 테스트하자.
    * 잡다한 개념을 연속으로 테스트하는 긴 테스트는 코드도, 결과도 보기 어렵다.

==== 클래스 ====

  * 모든 클래스는 하나의 책임만 가져야 한다.
  * 모든 클래스의 책임은 완전히 캡슐화되어야 한다.((클래스의 사용자는 클래스의 자세한 동작 방법을 모르더라도 원활하게 사용할 수 있어야 함))
  * 클래스의 응집도는 높게, 결합도(종속성)는 낮게 작성해야한다.
  * 디미터 법칙(([[http://shiconal.tistory.com/1|참고 사이트]]))을 참고하여 객체를 생성하자.
    * 예제 <code>
class Demeter{
    private Memeber member;
    public myMethod(){
        // ...
    }
    
    public followDemeterRule(OtherObject other){
        myMethod();  //자신의 메소드
        member.ok(); //자신의 멤버가 가진 메소드
        Local local = new Local(); 
        local.ok();  //메소드 내에서 직접 생성한 객체의 메소드
        other.ok();  //메소드의 인자로 넘어온 객체의 메소드
    }
}
</code>
    * 디미터 법칙을 따라 객체를 설계하므로써 여러 클래스 간의 결합도를 낮출수 있다.
    * 그렇다고 디미터 법칙이 만능은 아니다. 상황에 따라 알맞게 쓰자.
  * SOLID 원칙을 알아두고 적용하자.
    * SOLID: 소스 코드를 읽기 쉽고 확장하기 쉽게 될 때까지 소프트웨어 소스 코드를 리팩토링하는 과정에서 적용할 수 있는 일종의 지침
    * SRP(Single Responsibility Principle)
      * 하나의 클래스는 하나의 책임만을 가져야 한다.
    * OCP(Open/Closed Principle)
      * 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
      * 확장에 열려있음: 모듈의 동작을 확장/변경할 수 있다는 뜻
      * 변경에 닫혀있음: 모듈을 변경하지 않아도 기능을 확장할 수 있다는 뜻
      * 이 원칙이 잘 적용되면, 원래 코드를 변경하지 않아도 기존의 코드에 새로운 코드를 추가함으로써 기능의 추가나 변경이 가능하다.
    * LSP(Liskov Substitution Principle)
      * 자식 클래스를 부모 클래스로 바꿔도 동일하게 동작하도록 해야 한다.
      * 자식 클래스는 부모 클래스의 역할도 모두((비슷하게나마)) 가지고 있어야 한다는 뜻
    * ISP(Interface Segregation Principle)
      * 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
      * 인터페이스를 꼭 필요한 것만 모아 최소한으로 구성함으로써 클래스가 필요한 기능만을 골라 쓸 수 있도록 하자는 말
    * DIP(Dependency Inversion Principle)
      * 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.
      * {{ :wiki:clean_code:abstraction_and_specification.png?nolink|추상화와 구체화}}
      * 왼쪽은 구체화, 오른쪽이 추상화!! 상하위의 모듈 의존성을 최소화 하기 위해 추상화를 애용하자. 
    * 적용 방법에 관련해서는 [[http://www.nextree.co.kr/p6960/|여기]]를 참고
  * 클래스 검증에는 right-BICEP, CORRECT를 참조하면 좋다
  * 형식도 중요하다.
    * 클래스 이름은 명사형, 메소드 이름은 동사형
    * 변수는 위에, 메소드는 아래에
    * 메소드는 함께 쓰이는 것끼리 붙여서

==== 설계 ====

  * 켄트 백의 간단한 설계 규칙 네가지를 참조하자.
    - 모든 테스트를 실행하라.
    - 중복을 없애라.
    - 프로그래머의 의도를 표현하라.
    - 클래스와 메소드 수는 최소로 줄여라.
  * 추상화, 모듈화로 전체를 이루는 각 구성요소의 관심사를 분리하라.
    * 추상화 - 구체적인 것을 감추고 필요한 부분에 초첨을 맞추도록 하는 것
    * 모듈화 - 역할을 나누어 처리하는 것
  * 의존성 주입 기법 {{https://www.martinfowler.com/articles/injection.html#FormsOfDependencyInjection|참고}}
    * 구성요소간의 의존 관계가 소스코드 내부가 아닌 외부의 설정파일 등을 통해 정의되게 하는 디자인 패턴 중의 하나
    * 추후 작성될 코드를 미리 끌어다 쓰는 방식터페이스로 구현됨
    * 외부 클래스에 대한 의존성을 제거하여 추후 만들어질 외부 클래스에 부여하는 방법
    * 구현 방법은 다음과 같은 세가지
      * 생성자 주입 : 필요한 의존성을 모두 포함하는 클래스의 생성자를 만들고 그 생성자를 통해 의존성을 주입한다.
      * <code php>
class UserRepository implements RepositoryInterface {
    private $repository;
  
    public function __construct(RepositoryInterface $repository) {
        $this->repository = $repository;
    }
}
</code>
      * 세터(Setter)를 통한 주입 : 의존성을 입력받는 세터(Setter) 메소드를 만들고 이를 통해 의존성을 주입한다.
      * 인터페이스(Interface)를 통한 주입 : 의존성을 주입하는 함수를 포함한 인터페이스를 작성하고 이 인터페이스를 구현하도록 함으로써 실행시에 이를 통하여 의존성을 주입한다.
      * {{:wiki:clean_code:di_with_interface.png?nolink|}}
  * 제어 역전 (라이브러리와 프레임워크의 차이)
  * 로깅, 보안, 에러 검사 등 프로그램 전반에 걸쳐 신경써야할 요소(횡단 관심사)들은 각 요소별로 묶어 하나의 제어 단위로 작성하고 필요한 부분에서 호출하여 쓰도록 하는게 좋다.
  * 시스템의 점진적 발전을 돕기 위해 추후 의사 결정에 따라 유연하게 변경할 수 있는 구조로 설계해야한다.
  * 가능한 "가장 작은" 설계를 사용하자.

==== 동시 처리 ====

  * 동시에 동작하는 코드는 서로 결합 부분이 없는 것이 좋다.
  * __코드가 취급하는 자원이 무엇인지, 언제 그 자원을 사용할 것인지에 따라 동시 처리 코드를 분리하여 처리하는 전략이 유효하다.__((무엇과 언제를 분리한다고 되어 있다. 임의로 해석하여 넣어놓은 것으로 보충이 필요))
  * 한 프로그램은 작은 작업 주체(sub-program) 여러 개로 이루어진 구조로 볼 수 있다. 이러한 작은 작업 주체들은 동시에 동작하도록 하면 효율적인 프로그램을 만들 수 있다.
  * 동시 처리에 대한 오해와 상식을 잘 알고 사용하자.
    * 동시 처리에 대한 오해
      * 동시 처리를 하면 무조건 성능이 좋아진다.(X)
      * 동시 처리를 구현해도 설계는 변하지 않는다.(X)
      * 동시 처리를 위한 프레임워크를 사용하면 그 원리는 알 필요가 없다(X)
    * 동시 처리에 대한 상식
      * 동시 처리는 부하를 유발한다.
      * 동시 처리는 코드를 복잡하게 한다.
      * 동시 처리로 발생하는 버그는 재현하기 어렵다.
      * 동시 처리를 하기 위해서는 근본적인 설계각 필요하다.
  * 동시 처리를 위한 보완 원칙
    * 단일 책임 원칙(SRP)
      * 공유하는 자원은 최소화한다.
      * 각 스레드(메소드)는 캡슐화를 한다.
      * 쓰기 연산을 하지 않을거라면 사본을 가지고 읽기 전용으로 사용한다.
      * 스레드(메소드)에서는 최대한 각자의 지역 변수만 쓰도록 한다.
      * 동기적인 쓰레드가 많다면 단일 책임 원칙을 어겼을 가능성이 높다.
    * 뮤텍스(상호배제)를 적극 활용한다.
    * 생산자-소비자 모델, 읽기-쓰기((소수의 쓰기, 다수의 읽기))((갱신 루틴에 대한 고민이 필요)) 모델 등 자주 쓰는 모델을 참고한다.
    * 동기화 루틴을 최소화한다.
    * 테스트는 다양한 환경에서, CPU core보다 많은 수의 스레드(메소드)로, 실패하는 상황을 테스트한다.
    * 성능을 측정할 방법도 필요하다.

==== 점진적 개선 ====

  * 프로그래밍은 과학보단 공예에 가깝다. 퇴고가 없는 작문은 존재하지 않듯이 지저분한 코드를 먼저 짠 뒤에 정리해야 한다!
  * 일단 돌아가는 프로그램만을 개발하는 것은 자살행위.. 나쁜 코드는 독과 같음
  * 1년 전 코드보다 5분 전 코드가 정리하기 편하다. 코드 정리는 미루지 말자.
    * "나중은 결코 오지 않는다." -르블랑-
  * 인자 분석 코드는 확장성 있게 작성한다.
  * 한 기능을 추가하는데 수정해야 하는 부분이 너무 많다면 리펙토링의 적기이다.
  * 코드 개선 과정에서도 코드는 항상 깨끗하게 유지되어야 한다.

==== 코드 간 경계 ====

  * 외부 라이브러리를 쓰기 전에 학습 테스트를 작성하자.
    * 학습 테스트: 간단한 테스트 케이스를 작성하면서 사용법을 익히는 것
    * 학습 테스트는 외부 라이브러리의 업데이트로 발생하는 버그를 잡는데도 일조할 수 있다!
  * 외부 라이브러리는 예외 처리를 포함하여 감싸((wrapping))는 것이 좋다.
    * 참고 할만한 디자인 패턴 - adapter
    * <code python>
# Python code sample
class Target(object):
    def specific_request(self):
        return 'Hello Adapter Pattern!'

class Adapter(object):
    def __init__(self, adaptee):
        self.adaptee = adaptee

    def request(self):
        return self.adaptee.specific_request()

client = Adapter(Target())
print client.request()
</code>
    * 이렇게 함으로써 통제 불가한 외부 라이브러리와 통제 가능한 우리 코드의 경계를 설정해준다.
    * 외부 라이브러리를 다른 것으로 바꾸는데도 용이함
  * 인터페이스를 정의하고 외부 라이브러리와의 종속성을 최소화하여 경계를 깨끗하게 하자.
  * 상속과 위임 중에 위임이 더 낫다.
  * <code>
우리가 컨트롤할 수 있는 것에 의지하는게 그렇지 않은 것에 의지하는 것보다
낫다. 그렇지 않으면 그것들이 우리를 컨트롤할 것이다.
</code>
    * 우리 내부 코드가 서드파티 코드를 많이 알지 못하게 막아야 한다는 뜻
    * 즉, 외부 코드에 대해 너무 많은 것을 알고 조작하여 사용하면 우리 코드가  외부 코드에 종속될 수 있으니 주의하라는 말
