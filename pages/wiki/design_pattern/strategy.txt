====== Strategy 패턴 ======
===== 문서 개요 =====

  * 디자인 패턴(design pattern)의 구조적 패턴에 속하는 Strategy 패턴에 대한 개념을 정리한 문서
  * Strategy 패턴의 특징, 용례 등을 정리한 문서

-----

===== Strategy 패턴의 정의 =====

  * define algorithm interface in a base class and implementations in derived classes
  * Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from the clients that use it.
  * 특정 시점에서 어떤 프로그램을 수행할 것인가에 대한 결정을 할 수 있도록 함
  * 두가지 이상의 알고리즘을 캡슐화 하고 전략에 따라 알고리즘을 선택하여 작업을 수행함
  * 활용할 알고리즘의 선택은 클라이언트와 관계없이 이루어짐
  * 일반적으로 서브클래스를 만드는 방법을 대신하여 유연성을 극대화하기 위한 용도로 사용됨
  * polymorphism이라고도 함
  * 인터페이스 하나에 여러 기능!
  * It is also referred to as run-time (or dynamic) polymorphism, because the code generated by the compiler has sufficient indirection built-in so that the choice of sort algorithm can be decided at run-time 

===== Strategy 패턴이 유용한 상황 =====

  * minimize coupling

===== Strategy 패턴의 구조 =====

{{:wiki:design_pattern:strategy:strategy_airport.gif?nolink|}}

===== Strategy 패턴 작성 단계 =====

  - 상황에 따라 바꿔서 사용할 알고리즘에 대한 인터페이스를 작성
  - 생성한 인터페이스를 상속받아 각 알고리즘을 구현
  - 알고리즘 인터페이스를 가지는 사용자 객체를 생성
  - 사용자 객체에서 적절한 알고리즘을 골라서 알고리즘 인터페이스에 할당
  - 할당된 알고리즘으로 필요한 작업을 수행함

===== Strategy 패턴의 예시 =====

==== CPP(using heretagy) ====

<code cpp>
#include "iostream"
#include <stdlib.h>
using namespace std;

/*
   define algorithm interface in a base class 
   and implementations in derived classes
*/

class Algorithm
{
public:
    virtual int calculate(int a, int b) = 0;
};

class Addition:public Algorithm
{
public:
    int calculate(int a, int b){
        cout << "Addition operation is selected" << endl;
        cout << "operand a=" << a << ", ";
        cout << "operand b=" << b << endl;
        return a+b; 
    }
};

class Multiply:public Algorithm
{
public:
    int calculate(int a, int b){ 
        cout << "Multiply operation is selected" << endl;
        cout << "operand a=" << a << ", ";
        cout << "operand b=" << b << endl;
        return a*b; 
    }
};

class Power:public Algorithm
{
private:
    int calc_power(int a, int b){
        int temp = 1;
        for(int i = 0; i < b; i++){
            temp *= a;
        }
        return temp;
    }
public:
    int calculate(int a, int b){
        cout << "Power operation is selected" << endl;
        cout << "operand a=" << a << ", ";
        cout << "operand b=" << b << endl;
        return calc_power(a,b);
    }
};

class MyCalc{
private:
    Algorithm* operation;
public:
    MyCalc(){
        int condition;
        srand(time(0));
        condition = rand()%3;
        select_algorithm(condition);
    }
    void select_algorithm(int condition){
        if(operation != 0){ delete operation; }
        if(condition == 0){
            operation = new Addition();
        }
        else if(condition == 1){
            operation = new Multiply();
        }
        else if(condition == 2){
            operation = new Power();
        }
        else{
            operation = 0;
        }
    }
    int operate(int a, int b){
        if(operation == 0){
            cout << "Operation object is not initialized." << endl;
            return -1;
        }
        return operation->calculate(a, b);
    }
};

int main(int argc, char** argv)
{
    MyCalc* my_calc;
    my_calc = new MyCalc();
    int result = my_calc->operate(5,4);

    cout << "operation result: " << result << endl;
    return 0;
}

</code>

==== CPP(using template) ====

<code cpp>
#include "iostream"
#include <stdlib.h>
using namespace std;

/*
   define algorithm interface in a base class 
   and implementations in derived classes
*/

template<class ALGORITHM>
class MyCalc{
private:
    ALGORITHM operation;
public:
    int operate(int a, int b){
        return operation.calculate(a, b);
    }
};

class Addition
{
public:
    int calculate(int a, int b){
        cout << "Addition operation is selected" << endl;
        cout << "operand a=" << a << ", ";
        cout << "operand b=" << b << endl;
        return a+b; 
    }
};

class Multiply
{
public:
    int calculate(int a, int b){ 
        cout << "Multiply operation is selected" << endl;
        cout << "operand a=" << a << ", ";
        cout << "operand b=" << b << endl;
        return a*b; 
    }
};

class Power
{
private:
    int calc_power(int a, int b){
        int temp = 1;
        for(int i = 0; i < b; i++){
            temp *= a;
        }
        return temp;
    }
public:
    int calculate(int a, int b){
        cout << "Power operation is selected" << endl;
        cout << "operand a=" << a << ", ";
        cout << "operand b=" << b << endl;
        return calc_power(a,b);
    }
};


int main(int argc, char** argv)
{
    int condition;
    int result;
    srand(time(0));
    condition = rand()%3;
    if(condition == 0){
        MyCalc<Addition> my_calc;
        result = my_calc.operate(5,4);
    }
    else if(condition == 1){
        MyCalc<Multiply> my_calc;
        result = my_calc.operate(5,4);
    }
    else if(condition == 2){
        MyCalc<Power> my_calc;
        result = my_calc.operate(5,4);
    }
    cout << "operation result: " << result << endl;
    return 0;
}

</code>

==== PHP ====

<code php>
<?php
class User {
     
    public function CreateOrUpdate($name, $address, $mobile, $userid = null)
    {
        if( is_null($userid) ) {
            // it means the user doesn't exist yet, create a new record
        } else {
            // it means the user already exists, just update based on the given userid
        }
    }
}
</code>
